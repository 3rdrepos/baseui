/** * The contents of this file are subject to the Mozilla Public License * Version 1.1 (the "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at *  * http://www.mozilla.org/MPL/ *  * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. * See the License for the specific language governing rights and * limitations under the License. *  * The Original Code is BaseUI. *  * The Initial Developer of the Original Code is Romuald Quantin. * romu@soundstep.com (www.soundstep.com). *  * Portions created by *  * Initial Developer are Copyright (C) 2008-2010 Soundstep. All Rights Reserved. * All Rights Reserved. *  * BaseUI version: 4.0 * Actionscript version: 3.0 * Copyright: Mozilla Public License 1.1 (MPL 1.1) - http://www.opensource.org/licenses/mozilla1.1.php *  * You can use BaseUI in any flash site, except to include/distribute it in another framework, application, template, component or structure that is meant to build, scaffold or generate source files. *  */  package com.soma.ui.layouts {	import com.soma.ui.events.EventUI;	import com.soma.ui.vo.GapUI;	import com.soma.ui.vo.PaddingUI;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	/**	 * The VBoxUI class extends the LayoutUI class and works in the same way,	 * but it handles the position of its children by aligning them vertically in the box.	 * 	 * @example	 * <listing version="3.0">	 * var tile:TileUI = new TileUI(stage, 400, 300);	 * tile.backgroundColor = 0xFF0000;	 * tile.backgroundAlpha = 0.2;	 * tile.ratio = ElementUI.RATIO_IN;	 * tile.childrenGap = new GapUI(5, 5);	 * tile.childrenPadding = new PaddingUI(5, 5, 5, 5);	 * tile.childrenAlign = TileUI.ALIGN_BOTTOM_RIGHT;	 * tile.childrenDirection = TileUI.DIRECTION_HORIZONTAL;	 * addChild(tile);	 * 	 * for (var i:int=0; i&lt;16; ++i) {	 * 	var sprite:Sprite = new Sprite();	 * 	sprite.graphics.beginFill(0xFF0000, .5);	 * 	sprite.graphics.drawRect(0, 0, 100, 100);	 * 	tile.addChild(sprite);	 * }	 * 	 * tile.refresh();	 * </listing>	 * 	 * @see com.soma.ui.ElementUI	 * @see com.soma.ui.layouts.LayoutUI	 * @see com.soma.ui.vo.PaddingUI	 * @see com.soma.ui.vo.GapUI	 * 	 */		public class TileUI extends LayoutUI {		//------------------------------------		// private, protected properties		//------------------------------------				/** @private */		protected const LEFT:String = "left";		/** @private */		protected const RIGHT:String = "right";		/** @private */		protected const TOP:String = "top";		/** @private */		protected const BOTTOM:String = "bottom";				/** @private */		protected var _verticalAlign:String;		/** @private */		protected var _horizontalAlign:String;				/** @private */		protected var _childrenPadding:PaddingUI;		/** @private */		protected var _childrenGap:GapUI;		/** @private */		protected var _childrenAlign:String;		/** @private */		protected var _childrenDirection:String;				/** @private */		protected var _childrenEnable:Boolean = true;				//------------------------------------		// public properties		//------------------------------------				/** static constant for the children alignment position in the layout (property childrenAlign) */		public static const ALIGN_TOP_LEFT:String = "top_left";		/** static constant for the children alignment position in the layout (property childrenAlign) */		public static const ALIGN_TOP_RIGHT:String = "top_right";		/** static constant for the children alignment position in the layout (property childrenAlign) */		public static const ALIGN_BOTTOM_LEFT:String = "bottom_left";		/** static constant for the children alignment position in the layout (property childrenAlign) */		public static const ALIGN_BOTTOM_RIGHT:String = "bottom_right";				/** static constant for the children alignment direction in the layout (property childrenAlign) */		public static const DIRECTION_HORIZONTAL:String = "horizontal";		/** static constant for the children alignment direction in the layout (property childrenAlign) */		public static const DIRECTION_VERTICAL:String = "vertical";				//------------------------------------		// constructor		//------------------------------------				/**		 * Create a TileUI instance		 * @param reference DisplayObjectContainer instance used to calculate the size and position of the layout instance		 * @param width width of the layout (not disturbed by children)		 * @param height height of the layout (not disturbed by children)		 * @see com.soma.ui.layouts.LayoutUI#getRealWidth()		 * @see com.soma.ui.layouts.LayoutUI#getRealHeight()		 */		public function TileUI(reference:DisplayObjectContainer, width:Number = 100, height:Number = 100) {			super(reference, width, height);		}				//		// PRIVATE, PROTECTED		//________________________________________________________________________________________________				/** @private */		override protected function initialize():void {			super.initialize();			_childrenPadding = new PaddingUI();			_childrenGap = new GapUI();			_childrenAlign = ALIGN_TOP_LEFT;			_childrenDirection = DIRECTION_HORIZONTAL;			setPrivateAlignment();			_element.addEventListener(EventUI.UPDATED, updatedHandler);		}				/** @private */		protected function setPrivateAlignment():void {			var arr:Array = _childrenAlign.split("_");			_horizontalAlign = arr[1];			_verticalAlign = arr[0];		}				/** @private */		protected function updatedHandler(e:EventUI):void {			if (!_childrenEnable) return;			update();
		}				/** @private */		protected function update():void {			var startX:Number = 0;			var startY:Number = 0;			switch (_horizontalAlign) {				case LEFT:					startX = _childrenPadding.left;					break;				case RIGHT:					startX = _width - _childrenPadding.right;					break;			}			switch (_verticalAlign) {				case TOP:					startY = _childrenPadding.top;					break;				case BOTTOM:					startY = _height - _childrenPadding.bottom;					break;			}			var posX:Number = startX;			var posY:Number = startY;			var lastWidth:Number = 0;			var lastHeight:Number = 0;			var i:Number = 0;			var l:Number = numChildren;			for (i; i<l; ++i) {				var obj:DisplayObject = getChildAt(i);				if (_horizontalAlign == RIGHT && _childrenDirection == DIRECTION_HORIZONTAL) posX -= obj.width;				if (_verticalAlign == BOTTOM && _childrenDirection == DIRECTION_VERTICAL) posY -= obj.height;				if (_childrenDirection == DIRECTION_HORIZONTAL) {					if (_horizontalAlign == LEFT) {						if (posX + obj.width + _childrenPadding.right > _width) {							posX = startX;							if (_verticalAlign == TOP) posY += lastHeight + _childrenGap.vertical;							else posY -= lastHeight + _childrenGap.vertical;							lastHeight = 0;						}					}					else {						if (posX - _childrenPadding.left < 0) {							posX = startX - obj.width;							if (_verticalAlign == TOP) posY += lastHeight + _childrenGap.vertical;							else posY -= lastHeight + _childrenGap.vertical;							lastHeight = 0;						}					}				}				else {					if (_verticalAlign == TOP) {						if (posY + obj.height + _childrenPadding.bottom > _height) {							if (_horizontalAlign == LEFT) posX += lastWidth + _childrenGap.horizontal;							else posX -= lastWidth + _childrenGap.horizontal;							posY = startY;							lastWidth = 0;						}					}					else {						if (posY - _childrenPadding.top < 0) {							if (_horizontalAlign == LEFT) posX += lastWidth + _childrenGap.horizontal;							else posX -= lastWidth + _childrenGap.horizontal;							posY = startY - obj.height;							lastWidth = 0;						}					}				}				obj.x = (_horizontalAlign == RIGHT && _childrenDirection == DIRECTION_VERTICAL) ? posX-obj.width : posX; 				obj.y = (_verticalAlign == BOTTOM && _childrenDirection == DIRECTION_HORIZONTAL) ? posY-obj.height : posY; 				if (_childrenDirection == DIRECTION_HORIZONTAL) {					if (_horizontalAlign == LEFT) posX = obj.x + obj.width + _childrenGap.horizontal;					else posX = obj.x - _childrenGap.horizontal;				}				else {					if (_verticalAlign == TOP) posY = obj.y + obj.height + _childrenGap.vertical;					else posY = obj.y - _childrenGap.vertical;				}				if (obj.width > lastWidth) lastWidth = obj.width;				if (obj.height > lastHeight) lastHeight = obj.height;			}		}		// PUBLIC		//________________________________________________________________________________________________				/** @inheritDoc */		override public function dispose():void {			// dispose objects, graphics and events listeners			try {				if (_element != null) _element.removeEventListener(EventUI.UPDATED, updatedHandler);				_childrenPadding = null;				_childrenGap = null;				super.dispose();			} catch(e:Error) {				trace("Error in", this, "(dispose method):", e.message);			}		}				/**		 * PaddingUI instance (Value Object) that contains the necessary properties to set the padding value in the layout (left, right, top, bottom).		 * The padding is the distance between the DisplayObject children and the borders of the layout 		 * @see com.soma.ui.vo.PaddingUI		 */		public function get childrenPadding():PaddingUI {			return _childrenPadding;		}				public function set childrenPadding(value:PaddingUI) : void {			_childrenPadding = value;		}				/**		 * GapUI instance (Value Object) that contains the necessary properties to set the gap value between the DisplayObject children in the layout (horizontal, vertical).		 * The gap is the distance between each one of the DisplayObject children, horizontally and vertically. 		 * @see com.soma.ui.vo.GapUI		 */		public function get childrenGap():GapUI {			return _childrenGap;		}				public function set childrenGap(value:GapUI):void {			_childrenGap = value;		}				/**		 * Property to set the start position of the alignment of the DisplayObject children in the layout. 		 * The value can be TileUI.ALIGN_TOP_LEFT, TileUI.ALIGN_TOP_RIGHT, TileUI.ALIGN_BOTTOM_LEFT and TileUI.ALIGN_BOTTOM_RIGHT.		 */		public function get childrenAlign():String {			return _childrenAlign;		}				public function set childrenAlign(value:String):void {			if (value != ALIGN_TOP_LEFT &&				value != ALIGN_TOP_RIGHT &&				value != ALIGN_BOTTOM_LEFT &&				value != ALIGN_BOTTOM_RIGHT) {				throw new Error("Error in " + this + " (" + name + "): the align property must be, for example: TileUI.ALIGN_TOP_LEFT");			}			_childrenAlign = value;			setPrivateAlignment();		}				/**		 * Property to set the direction of the alignment of the DisplayObject children in the layout. 		 * The value can be TileUI.ALIGN_TOP_LEFT, TileUI.ALIGN_TOP_RIGHT, TileUI.ALIGN_BOTTOM_LEFT and TileUI.ALIGN_BOTTOM_RIGHT.		 */		public function get childrenDirection():String {			return _childrenDirection;		}				public function set childrenDirection(value:String):void {			if (value != DIRECTION_HORIZONTAL && value != DIRECTION_VERTICAL) {				throw new Error("Error in " + this + " (" + name + "): the align property must be DIRECTION_HORIZONTAL or DIRECTION_VERTICAL");			}			_childrenDirection = value;		}				/**		 * Indicates wether or not the layout will calculate the size and position of the DisplayObject children		 * @default true		 */		public function get childrenEnable():Boolean {			return _childrenEnable;		}				public function set childrenEnable(value:Boolean):void {			_childrenEnable = value;		}	}}